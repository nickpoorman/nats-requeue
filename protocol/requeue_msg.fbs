namespace flatbuf;

enum BackoffStrategy : byte { Undefined = 0, Exponential, Fixed }

/// RequeueMeta holds meta information about requeue message functionality.
table RequeueMeta {
    /// The number of times requeue should be attempted.
    retries: int64 = -1;

    /// The TTL for when the msssage should expire. This is useful for ensuring
	/// messages are not retried after a certain time.
    ttl: int64 = -1;

    /// The delay before the message should be replayed in nanoseconds.
    delay: int64 = -1;

    /// Backoff strategy that will be used for determining the next delay should
	/// the message fail to be acknowledged on replay. i.e. fixed interval or
	/// exponential
    backoff_strategy: BackoffStrategy;
}

/// The format for serializing requeue message.
table RequeueMessage {
    /// RequeueMeta holds meta information about requeue message functionality.
    meta: RequeueMeta;

    /// The message supports idempotency for safely retrying requests without 
    ///  accidentally performing the same operation twice. An idempotency key is 
    ///  a unique value generated by the client which the server uses to 
    ///  recognize duplicate messages. Specifically the underlying persistance 
    ///  layer may attempt to avoid duplicate writes. This does not guarentee 
    ///  at most once delivery of the message, only that duplicate messages 
    ///  which sink to same instance may not take up extra disk space.
    /// How you create unique keys is up to you, but we suggest using KSUIDs,
    ///  V4 UUIDs, or another random string with enough entropy to 
    ///  avoid collisions.
    /// If a key is not set on the recieved message, the requeue
    ///  implementation may attempt to set one.
    peristence_idempotency_key: string;

    /// The original subject of the message.
    original_subject: string;

    /// Original message payload
    original_payload: [ubyte];
}